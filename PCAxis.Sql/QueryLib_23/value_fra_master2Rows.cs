using System;
using System.Data;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;
using System.Xml.XPath;
using System.Globalization;

using PCAxis.Sql.DbConfig;

//This code is generated by master2Rows.xslt. Nope!

namespace PCAxis.Sql.QueryLib_23 {


    #region class   Value
    /// <summary> 
    /// Holds a list of ValueRows. 
    /// </summary> 
    public class ValueRow2HMDictionary {
        // One entry in the Dictionary for each ValueCode
        private Dictionary<string, ValueRow2HM> mValueRows = new Dictionary<string, ValueRow2HM>();
        internal Dictionary<string, ValueRow2HM> ValueRows {
            get { return mValueRows; }
            set { mValueRows = value; }
        }


        public ValueRow2HMDictionary(DataTable mTable, SqlDbConfig_23 dbconf, MetaQuery metaQuery)
        {
            string theValueCode="";
            string theLanguage;

           

            int sortOrder = 0;
            foreach (DataRow mRow in mTable.Rows) {
                theValueCode = mRow[dbconf.VSValue.ValueCodeCol.PureColumnName()].ToString();
                if (!mValueRows.ContainsKey(theValueCode))
                {
                    sortOrder += 1;  // this will be the sortorder for mainlanguage.  Since each language could have its own sortorder this well be set in the Valuetext and coukd be used by the calling program.
                    mValueRows.Add(theValueCode, new ValueRow2HM(mRow, dbconf, sortOrder));
                } //denne bør fel flyttes et par hakk ned       sto det, men det er vel slik for å kunne motta norsk og engelsk for samme kode
                    theLanguage = mRow["Language"].ToString();
                if (!mValueRows[theValueCode].texts.ContainsKey(theLanguage))
                {
                    mValueRows[theValueCode].texts.Add(theLanguage, new ValueText2HM(mRow, dbconf));
                }
            }


            ///Get valuecode which has metaid
            ///Including the MetaID in the sql "creating" the mTable will for "secondary language only" require a join
            /// to the primary language table. Expecting very few MetaId on values.
            /// Attaching them at a later stage should be faster ... but it takes a separate sql-call.
            /// 
            
            //adding MetaId on Value if there are any (should not happen often) 

            // picking one ValueCode  (the last) just to get the valuepool
            if (!string.IsNullOrEmpty(theValueCode))
            {
                Dictionary<string, ValueRow> withNotNullMetaIdInValuepool = metaQuery.GetValueRows(mValueRows[theValueCode].ValuePool, true);
                foreach (ValueRow val in withNotNullMetaIdInValuepool.Values)
                {
                    if (mValueRows.ContainsKey(val.ValueCode))
                    {
                        mValueRows[val.ValueCode].MetaId = val.MetaId;
                    }
                }
            }
        }
    }


    /// <summary> 
    /// Holds the  attributes for Value. The language dependent parts are stored in the texts dictionary which is indexed by language code. 
    /// </summary> 
    public class ValueRowHM {

        private String mValuePool;
        public String ValuePool {
            get { return mValuePool; }
        }

        private String mValueCode;
        public String ValueCode {
            get { return mValueCode; }
        }


        private string mMetaId;
        internal string MetaId
        {
            get { return mMetaId; }
        }

        public Dictionary<string, ValueTextHM> texts = new Dictionary<string, ValueTextHM>();


        public ValueRowHM(DataRow mRow, SqlDbConfig_23 dbconf,StringCollection languageCodes,int sortOrder)
        {
            this.mValuePool = mRow[dbconf.Value.ValuePoolCol.Label()].ToString();
            this.mValueCode = mRow[dbconf.Value.ValueCodeCol.Label()].ToString();
            this.mMetaId = mRow[dbconf.Value.MetaIdCol.Label()].ToString();  
            foreach (string languageCode in languageCodes) {
                texts.Add(languageCode, new ValueTextHM(mRow, dbconf, languageCode));
            }
        }

    }

    /// <summary> 
    /// Holds the language dependent attributes for Value for one language  
    /// </summary> 
    public class ValueTextHM
    {
        private String mValueTextS;
        public String ValueTextS
        {
            get { return mValueTextS; }
        }
        private String mValueTextL;
        public String ValueTextL
        {
            get { return mValueTextL; }
        }

        private String mSortCode;
        public String SortCode
        {
            get { return mSortCode; }
        }

        internal ValueTextHM(DataRow mRow, SqlDbConfig_23 dbconf,  String languageCode)
        {
            {
                if (dbconf.isSecondaryLanguage(languageCode))
                {
                    this.mValueTextS = mRow[dbconf.ValueLang2.ValueTextSCol.Label(languageCode)].ToString();
                    this.mValueTextL = mRow[dbconf.ValueLang2.ValueTextLCol.Label(languageCode)].ToString();
                    this.mSortCode = mRow[dbconf.ValueLang2.SortCodeCol.Label(languageCode)].ToString();

                } else
                {
                    this.mValueTextS = mRow[dbconf.Value.ValueTextSCol.Label()].ToString();
                    this.mValueTextL = mRow[dbconf.Value.ValueTextLCol.Label()].ToString();
                    this.mSortCode = mRow[dbconf.Value.SortCodeCol.Label()].ToString();
                }
            }
        }
    }


    public class ValueRow2HM {
        private String mValuePool;
        public String ValuePool {
            get { return mValuePool; }
        }
        private String mValueSet;
        public String ValueSet
        {
            get { return mValueSet; }
        }
        private String mValueCode;
        public String ValueCode {
            get { return mValueCode; }
        }
        private String mSortOrder;
       public String SortOrder {
           get { return mSortOrder; }
        }
        private String mFootnote;
        public String Footnote {
            get { return mFootnote; }
        }

        private string mMetaId;

        internal string MetaId
        {
            get { return mMetaId; }
            set { mMetaId = value; }
        }
        

        public Dictionary<string, ValueText2HM> texts = new Dictionary<string, ValueText2HM>();

        public ValueRow2HM(DataRow mRow, SqlDbConfig_23 dbconf, int sortOrder) {
            this.mValuePool = mRow[dbconf.VSValue.ValuePoolCol.PureColumnName()].ToString(); // VAL_Vardeforrad
            this.mValueSet = mRow[dbconf.VSValue.ValueSetCol.PureColumnName()].ToString(); // VAL_Vardemangd
            this.mValueCode = mRow[dbconf.VSValue.ValueCodeCol.PureColumnName()].ToString();
            this.mSortOrder = sortOrder.ToString();
            this.mFootnote = null;
        }
    }


    /// <summary> 
    /// Holds the language dependent attributes for Value for one language  
    /// </summary> 
    public class ValueText2HM {
        private String mSortCodeValue;
        public String SortCodeValue
        {
            get { return mSortCodeValue; }
        }
        private String mSortCodeVsValue;
        public String SortCodeVsValue
        {
            get { return mSortCodeVsValue; }
        }
        private String mValueTextS;
        public String ValueTextS {
            get { return mValueTextS; }
        }
        private String mValueTextL;
        public String ValueTextL {
            get { return mValueTextL; }
        }

        internal ValueText2HM(DataRow mRow, SqlDbConfig_23 dbconf) {
            this.mSortCodeValue = mRow["SortCodeValue"].ToString();
            this.mSortCodeVsValue = mRow["SortCodeVsValue"].ToString();
            this.mValueTextS = mRow[dbconf.Value.ValueTextSCol.PureColumnName()].ToString();
            this.mValueTextL = mRow[dbconf.Value.ValueTextLCol.PureColumnName()].ToString();
        }
    }


    #endregion Value


}
